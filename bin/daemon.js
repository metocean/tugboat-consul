// Generated by CoffeeScript 1.8.0
var Sequencer, Tugboat, Watch, consulhost, fatalerror, hascontainers, host, http, key, launch, needsupdate, os, parse_url, path, seq, series, temperrors, url;

require('colors');

Watch = require('consul-utils').Watch;

Tugboat = require('tugboat');

Sequencer = require('../src/sequencer');

os = require('os');

http = require('http');

parse_url = require('url').parse;

series = require('../src/series');

seq = new Sequencer();

host = os.hostname();

if (process.env.TUGBOAT_HOST != null) {
  host = process.env.TUGBOAT_HOST;
}

consulhost = 'http://127.0.0.1:8500';

if (process.env.CONSUL_HOST != null) {
  consulhost = process.env.CONSUL_HOST;
}

if (consulhost.indexOf('http://') !== 0) {
  consulhost = "http://" + consulhost;
}

key = "tugboat/" + host + "/";

path = "/v1/kv/" + key;

url = "" + consulhost + path + "?keys";

temperrors = function(errors) {
  var err, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = errors.length; _i < _len; _i++) {
    err = errors[_i];
    if (err.stack) {
      _results.push(console.error(err.stack));
    } else {
      _results.push(console.error(err));
    }
  }
  return _results;
};

fatalerror = function(e) {
  console.error(e);
  return process.exit(-1);
};

hascontainers = function(group) {
  var service, _, _ref;
  _ref = group.services;
  for (_ in _ref) {
    service = _ref[_];
    if (service.containers.length !== 0) {
      return true;
    }
  }
  return false;
};

needsupdate = function(group) {
  var service, _, _ref;
  _ref = group.services;
  for (_ in _ref) {
    service = _ref[_];
    if (service.diff.stop.length !== 0) {
      return true;
    }
    if (service.diff.rm.length !== 0) {
      return true;
    }
    if (service.diff.start.length !== 0) {
      return true;
    }
    if (service.diff.create !== 0) {
      return true;
    }
  }
  return false;
};

launch = function() {
  console.log("Tugboat Consul is running for host " + host + "...");
  return new Watch(url, function(groups) {
    groups = groups.map(function(g) {
      return g.substr(key.length);
    }).filter(function(g) {
      if (g.length === 0) {
        return false;
      }
      if (g.indexOf('/') !== -1) {
        return false;
      }
      return true;
    });
    return seq.exec('Update received from consul', function(callback) {
      var tugboat;
      console.log("Update received from consul, groups enabled: " + (groups.join(', ')) + ".");
      console.log('Querying tugboat...');
      tugboat = new Tugboat.API();
      return tugboat.init(function(errors) {
        if (errors != null) {
          temperrors(errors);
          return callback();
        }
        return tugboat.diff(function(err, results) {
          var g, group, groupname, groupstocull, groupstoupdate, tasks, _fn, _fn1, _i, _j, _k, _len, _len1, _len2;
          if (err != null) {
            temperrors([err]);
            return callback();
          }
          tasks = [];
          groupstoupdate = [];
          groupstocull = [];
          for (_i = 0, _len = groups.length; _i < _len; _i++) {
            g = groups[_i];
            if (results[g] == null) {
              console.log("Group " + g + " is (unknown) and has no containers... nothing to do");
              continue;
            }
            group = results[g];
            delete results[g];
            if (!needsupdate(group)) {
              continue;
            }
            groupstoupdate.push(group);
          }
          for (groupname in results) {
            group = results[groupname];
            if (!hascontainers(group)) {
              continue;
            }
            if (group.name.indexOf('tugboat') === 0) {
              continue;
            }
            if (group.name.indexOf('_') === 0) {
              continue;
            }
            groupstocull.push(group);
          }
          _fn = function(group) {
            return tasks.push(function(cb) {
              console.log("Culling group " + group.name + "...");
              return tugboat.groupcull(group, function(errors, messages) {
                var message, _k, _len2;
                temperrors(errors);
                for (_k = 0, _len2 = messages.length; _k < _len2; _k++) {
                  message = messages[_k];
                  console.log(message);
                }
                return cb();
              });
            });
          };
          for (_j = 0, _len1 = groupstocull.length; _j < _len1; _j++) {
            group = groupstocull[_j];
            _fn(group);
          }
          _fn1 = function(group) {
            return tasks.push(function(cb) {
              if (!group.isknown) {
                console.log("Updating group " + group.name + " (unknown)... will start anything stopped");
              } else {
                console.log("Updating group " + group.name + "...");
              }
              return tugboat.groupup(group, function(errors, messages) {
                var message, _l, _len3;
                temperrors(errors);
                for (_l = 0, _len3 = messages.length; _l < _len3; _l++) {
                  message = messages[_l];
                  console.log(message);
                }
                return cb();
              });
            });
          };
          for (_k = 0, _len2 = groupstoupdate.length; _k < _len2; _k++) {
            group = groupstoupdate[_k];
            _fn1(group);
          }
          tasks.push(function(cb) {
            if (groupstoupdate.length === 0 && groupstocull.length === 0) {
              console.log('Everything is up to date');
            } else {
              console.log('Tugboat changes complete');
            }
            return cb();
          });
          return series(tasks, callback);
        });
      });
    });
  });
};

http.get(url, function(res) {
  var params;
  if (res.statusCode !== 404) {
    return launch();
  }
  params = parse_url(consulhost);
  params.path = path;
  params.method = 'PUT';
  return http.request(params, function(res) {
    return launch();
  }).on('error', fatalerror).end();
}).on('error', fatalerror);
